{
  "design-patterns": [
    {
      "question": "구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현하는 패턴",
      "answer": ["추상 팩토리", "추상 팩토리 패턴", "추상팩토리", "추상팩토리패턴"]
    },
    {
      "question": "작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성하는 패턴",
      "answer": ["빌더", "빌더 패턴", "빌더패턴"]
    },
    {
      "question": "객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴",
      "answer": ["팩토리 메소드", "팩토리 메소드 패턴", "팩토리메소드"]
    },
    {
      "question": "원본 객체를 복제하는 방법으로 객체를 생성하는 패턴",
      "answer": ["프로토타입", "프로토타입 패턴", "프로토타입패턴"]
    },
    {
      "question": "하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없는 패턴",
      "answer": ["싱글톤", "싱글턴", "싱글톤 패턴", "싱글턴 패턴"]
    },
    {
      "question": "호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴",
      "answer": ["어댑터", "어댑터 패턴", "어댑터패턴"]
    },
    {
      "question": "구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴",
      "answer": ["브리지", "브리지 패턴", "브릿지", "브릿지 패턴"]
    },
    {
      "question": "여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴",
      "answer": ["컴포지트", "컴포지트 패턴", "컴포지트패턴"]
    },
    {
      "question": "객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴",
      "answer": ["데코레이터", "데코레이터 패턴", "데코레이터패턴"]
    },
    {
      "question": "복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴",
      "answer": ["퍼사드", "퍼사드 패턴", "퍼사드패턴"]
    },
    {
      "question": "인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴",
      "answer": ["플라이웨이트", "플라이웨이트 패턴", "플라이웨이트패턴"]
    },
    {
      "question": "복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하는 패턴으로 대리자라고도 불림",
      "answer": ["프록시", "프록시 패턴", "프록시패턴"]
    },
    {
      "question": "요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴",
      "answer": ["책임 연쇄", "책임 연쇄 패턴", "책임연쇄"]
    },
    {
      "question": "요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴",
      "answer": ["커맨드", "커맨드 패턴", "커맨드패턴"]
    },
    {
      "question": "언어에 문법 표현을 정의하는 패턴",
      "answer": ["인터프리터", "인터프리터 패턴", "인터프리터패턴"]
    },
    {
      "question": "자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴",
      "answer": ["반복자", "반복자 패턴", "반복자패턴", "이터레이터", "이터레이터 패턴", "이터레이터패턴"]
    },
    {
      "question": "수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴",
      "answer": ["중재자", "중재자 패턴", "중재자패턴"]
    },
    {
      "question": "특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴",
      "answer": ["메멘토", "메멘토 패턴", "메멘토패턴"]
    },
    {
      "question": "한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴",
      "answer": [
        "옵서버",
        "옵서버 패턴",
        "옵서버패턴",
        "관찰자",
        "관찰자 패턴",
        "관찰자패턴",
        "옵저버",
        "옵저버 패턴",
        "옵저버패턴"
      ]
    },
    {
      "question": "객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴",
      "answer": ["상태", "상태 패턴", "상태패턴"]
    },
    {
      "question": "동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴",
      "answer": ["전략", "전략 패턴", "전략패턴"]
    },
    {
      "question": "상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴",
      "answer": ["템플릿 메소드", "템플릿 메소드 패턴", "템플릿메소드"]
    },
    {
      "question": "각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴",
      "answer": ["방문자", "방문자 패턴", "방문자패턴"]
    }
  ]
}
